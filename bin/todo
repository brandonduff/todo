#!/usr/bin/env ruby
require 'gli'
begin # XXX: Remove this begin/rescue before distributing your app
  require 'todo'
rescue LoadError
  STDERR.puts "In development, you need to use `bundle exec bin/todo` to run your app"
  STDERR.puts "At install-time, RubyGems will make sure lib, etc. are in the load path"
  STDERR.puts "Feel free to remove this message from bin/todo now"
  exit 64
end

include GLI::App

program_desc 'Describe your application here'

version Todo::VERSION

subcommand_option_handling :normal
arguments :strict

desc 'Describe some switch here'
switch [:s, :switch]

desc 'Describe some flag here'
default_value 'the default'
arg_name 'The name of the argument'
flag [:f, :flagname]

desc 'Create a new todo'
arg_name 'Todo text'
command :new, :n do |c|
  c.desc 'Describe a switch to new'
  c.switch :s

  c.desc 'Path to todo file'
  c.default_value File.join(ENV['HOME'], '.todos.txt')
  c.flag [:f, :filename]
  c.action do |global_options, options, args|
    @tasks.add_task(Todo::TaskBuilder.new(args.join(' ')).build)
    @tasks.save(File.open(options[:filename], 'a'))
  end
end

desc 'Lists todos'
command :list, :ls do |c|
  c.desc 'Path to todo file'
  c.default_value File.join(ENV['HOME'], '.todos.txt')
  c.flag [:f, :filename]

  c.desc 'List all todos (including done)'
  c.switch [:a, :all]


  c.action do |global_options, options, args|
    if options[:all]
      puts @tasks
    else
      puts @tasks.unfinished_tasks
    end
  end
end

desc 'Marks the next unfinished todo as done'
arg_name 'Takes a filename'
command :done, :d do |c|
  c.desc 'Path to todo file'
  c.default_value File.join(ENV['HOME'], '.todos.txt')
  c.flag [:f, :filename]

  c.action do |global_options, options, args|
    puts @tasks.done
    puts @tasks.unfinished_tasks
    @tasks.save(File.open(options[:filename], 'a'))
  end
end

desc 'Clears all done todos'
arg_name 'Takes a filename'
command :clear do |c|
  c.desc 'Path to todo file'
  c.default_value File.join(ENV['HOME'], '.todos.txt')
  c.flag [:f, :filename]

  c.action do |global_options, options, args|
    @tasks.clear
    @tasks.save(File.open(options[:filename], 'a'))
  end
end

desc 'Unmarks the last done todo as done'
command :undo do |c|
  c.desc 'Path to todo file'
  c.default_value File.join(ENV['HOME'], '.todos.txt')
  c.flag [:f, :filename]

  c.action do |_global_options, options, _args|
    @tasks.undo
    puts @tasks.unfinished_tasks
  end
end

desc 'Get and set the current day'
arg_name 'New date'
command :day do |c|
  c.desc 'Path to current day file'
  c.default_value File.join(ENV['HOME'], '.current_day.txt')
  c.flag [:f, :filename]

  c.action do |_global_options, options, args|
    if (new_day = args.first)
      Todo::Persistence.for(new_day).write_to(File.open(options[:filename], 'a'))
    else
      puts File.read(options[:filename])
    end
  end
end

pre do |global, command, options, args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  initial_buffer = File.exist?(options[:filename]) ? File.read(options[:filename]) : ''
  @tasks = Todo::TaskList.new(StringIO.new(initial_buffer))
end

post do |global, command, options, args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

exit run(ARGV)
